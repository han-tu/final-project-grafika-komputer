<!DOCTYPE html>
<html>

<head>
    <!-- bagian script ntr tambahin aja sesuai sama yang dipake, klo ga dipake gaapa -->
    <meta charset="utf-8">
    <title>FP Grafika Komputer</title>
    <link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">
                Click to play
            </p>
            <p>
                Move: WASD<br />
                Jump: SPACE<br />
                Look: MOUSE
            </p>
        </div>
    </div>
</body>

</html>

<script type="module">
    import { PointerLockControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/PointerLockControls.js';
    import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js';

    import { createCamera } from './object/camera.js';
    import { createScene } from './object/scene.js';
    import { createPlane } from './object/plane.js';
    import { createBox } from './object/wall.js';
    import { createHemisphere } from './object/light.js';
    import { getOnKeyUpEvent } from './event/onKeyUp.js';
    import { getOnKeyDownEvent } from './event/onKeyDown.js';
    import { Move } from './event/Move.js';

    let move = new Move();

    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    let objects = [];

    let camera = createCamera(window);                  // Camera
    let scene = createScene(0xffffff);                  // Scene
    let light = createHemisphere(0.5, 20, 0.75, scene); // Light

    // Plane
    let textureUrl = 'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/4k/weathered_brown_planks/weathered_brown_planks_diff_4k.jpg';
    let planeSize = 2000;
    let plane = createPlane(planeSize, textureUrl, scene);

    // Wall
    let cubeSize = 10;
    let cubeColor = 0xFF3E2723;
    let wall = createBox(cubeSize, cubeColor);
    wall.position.set(20, cubeSize / 2, 20);
    objects.push(wall);
    scene.add(wall);
    

    let controls;
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');
    { // Pointer Lock Control
        controls = new PointerLockControls(camera, document.body)

        instructions.addEventListener('click', function () {
            controls.lock();
        });

        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });

        controls.addEventListener('unlock', function () {
            blocker.style.display = 'block';
            instructions.style.display = '';
        });

        scene.add(controls.getObject());
    }

    // Add Event to EventListener on Page
    document.addEventListener('keydown', getOnKeyDownEvent(move, velocity));
    document.addEventListener('keyup', getOnKeyUpEvent(move));


    let renderer;
    { // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    // Resize Window Event
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);


    let raycaster;
    { // Raycaster
        raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
    }


    function animate() {

        requestAnimationFrame(animate);

        const time = performance.now();

        if (controls.isLocked === true) {

            raycaster.ray.origin.copy(controls.getObject().position);
            raycaster.ray.origin.y -= 10;

            const intersections = raycaster.intersectObjects(objects, false);

            const onObject = intersections.length > 0;

            const delta = (time - prevTime) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

            direction.z = Number(move.getMoveForwardStatus()) - Number(move.getMoveBackwardStatus());
            direction.x = Number(move.getMoveRightStatus()) - Number(move.getMoveLeftStatus());
            direction.normalize(); // this ensures consistent movements in all directions

            if (move.getMoveForwardStatus() || move.getMoveBackwardStatus()) velocity.z -= direction.z * 400.0 * delta;
            if (move.getMoveLeftStatus() || move.getMoveRightStatus()) velocity.x -= direction.x * 400.0 * delta;

            if (onObject === true) {
                if (velocity.y < 0) {
                    velocity.y = 0;
                    move.setCanJumpStatus(true);
                }
                else {
                    console.log(intersections);
                }



            }

            controls.moveRight(- velocity.x * delta);
            controls.moveForward(- velocity.z * delta);

            controls.getObject().position.y += (velocity.y * delta); // new behavior

            if (controls.getObject().position.y < 10) {

                velocity.y = 0;
                controls.getObject().position.y = 10;

                move.setCanJumpStatus(true);

            }

        }

        prevTime = time;

        renderer.render(scene, camera);

    }

    animate();

</script>